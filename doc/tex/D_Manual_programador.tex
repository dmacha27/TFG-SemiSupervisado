\apendice{Documentación técnica de programación}

\section{Introducción}
En esta sección se presenta toda la documentación técnica del desarrollo del
proyecto. Trata de ser una guía para entender cómo se ha hecho el proyecto
comenzando por los directorios y su contenido, con un manual introductorio para
un programador iniciado en el proyecto, explicación y ejemplificación de la
instalación del mismo y las pruebas que se han realizado para validarlo.

\section{Estructura de directorios}
Estos son los directorios en los que se organiza el proyecto:

\begin{figure}[H]
    \dirtree{% 
        .1 /.
        .2 \textbf{algoritmos}: \begin{minipage}[t]{8cm}
            algoritmos Semi-Supervisados implementados{.}\\
        \end{minipage}.
        .3 \textbf{test}: \begin{minipage}[t]{8cm}
            directorios y ficheros mediante los que se valida el
            desarrollo software correcto del proyecto{.}\\
        \end{minipage}.
        .4 \textbf{check\_implementations}: \begin{minipage}[t]{8cm}
            pruebas para la validación de los algoritmos{.}\\
        \end{minipage}.
        .5 \textbf{results}: \begin{minipage}[t]{8cm}
            ficheros CSV con resultados de validación cruzada{.}\\
        \end{minipage}.
        .4 \textbf{profile\_results}: \begin{minipage}[t]{8cm}
            resultados de los procesos de <<profiling>>{.}\\
        \end{minipage}.
        .4 \textbf{test\_files}: \begin{minipage}[t]{8cm}
            ficheros de prueba (ARFF y CSV) para las pruebas{.}\\
        \end{minipage}.
        .3 \textbf{utilidades}: \begin{minipage}[t]{8cm}
            utilidades (programas) que realizan ciertos pasos de la
            aplicación y de los algoritmos para centralizar estos procedimientos (comunes){.}\\
        \end{minipage}.
        .2 \textbf{docs}: \begin{minipage}[t]{8cm}
            documentación teórica y técnica del proyecto (hecha en \LaTeX){.}\\
        \end{minipage}.
        .3 \textbf{img}: \begin{minipage}[t]{8cm}
            imágenes utilizadas para la generación de la documentación{.}\\
        \end{minipage}.
        .3 \textbf{tex}: \begin{minipage}[t]{8cm}
            archivos de texto plano con código \LaTeX{.}\\
        \end{minipage}.
        .2 \textbf{web}: \begin{minipage}[t]{8cm}
            estructura o código de la aplicación Web{.}\\
        \end{minipage}.
        .3 \textbf{datasets}: \begin{minipage}[t]{8cm}
            contiene (durante el funcionamiento de la aplicación) todos los conjuntos de
            datos que los usuarios introducen{.}\\
        \end{minipage}.
        .4 \textbf{seleccionar}: \begin{minipage}[t]{8cm}
            conjuntos de datos para seleccionar de prueba, principalmente
            durante el desarrollo de la aplicación{.} También almacena el fichero de
            prueba que los usuarios pueden descargar{.}\\
        \end{minipage}.
    }
\end{figure}

\begin{figure}[H]
    \dirtree{%
        .1 \textbf{web}: \begin{minipage}[t]{10cm}
            estructura o código de la aplicación Web{.}\\
        \end{minipage}.
        .2 \textbf{static}: \begin{minipage}[t]{10cm}
            ficheros estáticos que utiliza la aplicación Web: CSS,
            Javascript o JSON{.}\\
        \end{minipage}.
        .2 \textbf{templates}: \begin{minipage}[t]{10cm}
            plantillas HTML (Jinja2) que renderiza la aplicación Web
            (Flask){.}\\
        \end{minipage}.
        .2 \textbf{translations}: \begin{minipage}[t]{10cm}
            traducciones de los textos de la aplicación (por idiomas){.}\\
        \end{minipage}.
    }
\end{figure}

\section{Manual del programador}
El objetivo de este manual es dar al lector/desarrollador que comience a
trabajar con el proyecto el conocimiento necesario para continuarlo. Se ha de
tener en cuenta que lo descrito a continuación es lo que se ha utilizado para el
entorno desarrollo inicial y será explicado para este.

En primer lugar se listan las herramientas consideradas para el desarrollo:
\begin{itemize}
    \item Python 3.10: Todo el proyecto, desde su inicio, ha sido desarrollado en la versión 3.10.
    \item Git: Necesario para continuar con el control de versiones del proyecto.
    \item Pycharm: Editor de código utilizado, podría utilizarse otro si así se considerase.
\end{itemize}

Python puede descargarse desde su página principal\footnote{Descargas de
Python: \url{https://www.python.org/downloads/}}. En las herramientas no se ha
mencionado <<pip>> (el administrador de paquetes) pues desde la versión 3.4 de
Python este está instalado con él, sin embargo, sería conveniente asegurarse de
ello comprobado la versión pues en el futuro será necesario. 

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Comprobar pip]
\begin{minted}{shell}
pip --version
python -m ensurepip --upgrade
\end{minted}
\end{tcolorbox}

Y de forma general, comprobar que los binarios pueden ser utilizados por lo
menos en el entorno del programador (en su usuario o equipo completo).

En el caso de Git, desde Linux simplemente se puede realizar con el gestor de
paquetes:

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Instalar Git en Linux]
\begin{minted}{shell}
sudo apt install git-all
\end{minted}
\end{tcolorbox}

Si el entorno es Windows existe un instalador directo que puede descargarse
desde la página de Git SCM (Source code management)\footnote{Git para Windows:
\url{https://git-scm.com/download/win}}.

Pycharm se puede descargar tanto para Windows como Linux en la página oficial de
JetBrains\footnote{Pycharm: \url{https://www.jetbrains.com/pycharm/download/}}.

\subsection{Comprensión de la estructura}

Se recomienda leer la sección anterior donde se pueden consultar todos los
directorios del proyecto con una breve descripción. La preparación del entorno
virtual con el que trabajar se explicará en la próxima sección.

El proyecto se desarrolla en dos ramas comunicadas (de forma unidireccional):
los algoritmos implementados y la aplicación Web. La aplicación es la que
utiliza los algoritmos para obtener la información presentada en la Web.

\paragraph{Algoritmos semi-supervisados} (contenidos en el directorio algoritmos):
Los algoritmos desarrollados y nuevos han de situarse en este directorio como
raíz. La idea es que cada fichero <<.py>>, homónimo al algoritmo, contenga la
definición de un objeto que encapsule el desarrollo del mismo, para que no haya
confusión.

Estructura de los objetos (mínima):

\textbf{Constructor}: Donde se configuran los parámetros que necesita el algoritmo. Es
recomendable realizar una validación de los mismos por si fueran utilizados de manera individual.

\textbf{Método de entrenamiento (Fit)}: Dado que estos algoritmos están pensados no solo
para entrenar sino para almacenar el proceso de entrenamiento y estadísticas,
siempre ha de recibir el conjunto de entrenamiento (x, y), el conjunto de test
(x\_test, y\_test) y el nombre de las características de cada instancia.

En principio, el método de desarrollo seguido es el de primero implementar el
algoritmo para después añadir, con la librería Pandas, un registro completo de
los momentos de etiquetado y de las estadísticas de cada iteración.

Este método deberá retornar el registro de etiquetado, el estadístico y el
número de iteraciones realizadas.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera fit]
\begin{minted}{python}
def fit(x, y, x_test, y_test, features)
\end{minted}
\end{tcolorbox}

Es importante tener en cuenta que esta estructura puede variar en la medida de
cómo sea el algoritmo. Por ejemplo, en el caso de Democratic Co-Learning se
hacía imprescindible añadir estadísticas específicas para cada clasificador que
encapsula y por tanto, retornaba más elementos.

\textbf{Método de predicción}: En el caso de algoritmos que trabajan con un único
clasificador podría ser opcional, pero en el caso de varios, es necesario
considerar cómo se predicen las etiquetas en combinación.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera predict]
\begin{minted}{python}
def predict(self, instances)
\end{minted}
\end{tcolorbox}
    

\textbf{Métodos estadísticos}: Dependiendo de lo que se desee mostrar en la
aplicación, se incluirán ciertas estadísticas.

La convención utilizada hasta ahora es crear un método que comience por <<get\_>>
seguido del nombre de la estadística, por ejemplo get\_accuracy\_score.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera ejemplo estadística]
\begin{minted}{python}
def get_accuracy_score(self, x_test, y_test):
\end{minted}
\end{tcolorbox}

\paragraph{Utilidades} En el directorio de las utilidades se han de alojar
aquellos métodos que se reutilizan en el proyecto (y que intervenga algún paso
del algoritmo, por ejemplo, la carga de datos). 

\paragraph{Tests} El desarrollo del software debe ser validado para asegurar su
correcto funcionamiento antes las distintas casuísticas. Cuando se desarrolla
código en esta sección, sus casos de prueba codificados deben incluirse en el
directorio correspondiente. Se utiliza <<pytest>> como \textit{framework} de
pruebas.


\paragraph{Aplicación Web} (contenida en el directorio web):  

La aplicación está desarrollada con el <<micro-framework>> Flask, que permite la
creación de aplicaciones Web en Python. Toda la lógica de la aplicación
(exceptuando el contenido dinámico) está codificado en <<app.py>>. 

\textbf{app}: En este fichero se definen todas las posibles rutas a las que los
usuarios pueden acceder. Si se desea añadir alguna nueva, las anotaciones de Flask
permiten especificarlas.

La visualización de un algoritmo se centra en dos pasos: la configuración del
mismo (en las rutas <</configuracion/<algoritmo>\>>>) donde se debe renderizar
una página con el formulario de configuración, y la visualización
(<</visualizacion/<algoritmo>\>>>) donde se renderiza la página donde se
encuentran todos los gráficos de los algoritmos. Además, existe un paso
intermedio en el que se obtienen los datos de la ejecución de los algoritmos,
este paso no es una ruta accesible, es un método auxiliar que accede el propio
usuario (su navegador) para obtener la información. Por lo general, la
convención utilizada es que todos los métodos y rutas lleven el nombre del
algoritmo. Existe documentación en línea.

\textbf{Plantillas}: Flask utiliza el motor de plantillas Jinja2, que añaden
instrucciones en HTML. Obviando que cada algoritmo tiene sus particularidades,
están organizadas mediante la extensión de plantillas. De forma general, añadir
un algoritmo podría solo intervenir la creación de una plantilla de
configuración y otra de visualización. En ambos casos se tiene una plantilla
base de la que se debe extender.

\textbf{Ficheros estáticos}: El contenido dinámico debe ser creado mediante
Javascript, el desarrollo se ha realizado en <<Vanilla>>. En menor medida, los
estilos deben ser retocados en estos ficheros aunque en principio la aplicación
está estilada con Bootstrap 5.

Otra parte muy importante es la adición de clasificadores base que están
almacenados en el fichero JSON <<parametros>>. Hasta el momento del desarrollo
solo existen dos tipos de entradas, los selectores y los numéricos (para los
clasificadores).

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Estructura para añadir clasificadores y sus parámetros]
\begin{minted}{json}
{
    "ClasificadorBase": {
        "parametro_numerico": {
        "label": "Nombre a mostrar",
        "type": "number",
        "step": 1,
        "min": 1,
        "max": "Infinity",
        "default": 5
        },
        "parametro_selector": {
        "label": "Nombre a mostrar",
        "type": "select",
        "options": ["lista", "de", "elementos"],
        "default": "elementos"
        }
    }
}
\end{minted}
\end{tcolorbox}

Con <<step>> se debe tener en cuenta la posibilidad de permitir números enteros
(al introducir 1) o números decimales (al incluir un flotante por ejemplo, 0.01)

\textbf{Conjunto de datos}: Los conjuntos de datos de los usuarios (vinculados a
sus sesiones) se almacenan localmente en la aplicación con el <<Timestamp>>
concatenado el nombre del fichero introducido.

\textbf{Internacionalización}: Una de las herramientas utilizadas es Babel,
para incluir nuevo texto en la aplicación se debe utilizar la función
<<gettext()>> (en Jinja2). Y a continuación utilizar la librería.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Proceso de internacionalización (desde /web)]
\begin{minted}{shell}
Extraer los texto encapsulados por gettext
$ pybabel extract -F babel.cfg -o messages.pot . 

Actualizar los texto extraidos en el fichero de compilación
$ pybabel update -i messages.pot -d translations

Compilar de las traducciones
$ pybabel compile -d translations 
\end{minted}
\end{tcolorbox}
 
A partir de aquí la propia aplicación utilizará las traducciones dependiendo del
usuario.


\section{Compilación, instalación y ejecución del proyecto}

\section{Pruebas del sistema}
