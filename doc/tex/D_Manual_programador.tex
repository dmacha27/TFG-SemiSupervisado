\apendice{Documentación técnica de programación}

\section{Introducción}
En esta sección se presenta toda la documentación técnica del desarrollo del
proyecto. Trata de ser una guía para entender cómo se ha hecho el proyecto
comenzando por los directorios y su contenido, con un manual introductorio para
un programador iniciado en el proyecto, explicación y ejemplificación de la
instalación del mismo y las pruebas que se han realizado para validarlo.

\tcbset{colback=red!5!white,fonttitle=\bfseries}
\begin{tcolorbox}[enhanced,title=Repositorio Github,
frame style={left color=blue!75!black,
right color=cyan!75!black}]
\url{https://github.com/dma1004/TFG-SemiSupervisado}
\end{tcolorbox}

\section{Estructura de directorios}
Estos son los directorios en los que se organiza el proyecto:

\begin{figure}[H]
    \dirtree{% 
        .1 /.
        .2 \textbf{algoritmos}: \begin{minipage}[t]{8cm}
            algoritmos Semi-Supervisados implementados{.}\\
        \end{minipage}.
        .3 \textbf{test}: \begin{minipage}[t]{8cm}
            directorios y ficheros mediante los que se valida el
            desarrollo software correcto del proyecto{.}\\
        \end{minipage}.
        .4 \textbf{check\_implementations}: \begin{minipage}[t]{6cm}
            pruebas para la validación de los algoritmos{.}\\
        \end{minipage}.
        .5 \textbf{results}: \begin{minipage}[t]{8cm}
            ficheros CSV con resultados de validación cruzada{.}\\
        \end{minipage}.
        .4 \textbf{check\_utils}: \begin{minipage}[t]{8cm}
            pruebas para la validación de las utilidades{.}\\
        \end{minipage}.
        .5 \textbf{test\_files}: \begin{minipage}[t]{8cm}
            ficheros de prueba (ARFF y CSV) para las pruebas{.}\\
        \end{minipage}.
        .4 \textbf{profiling}: \begin{minipage}[t]{8cm}
            pruebas para medir el tiempo de ejecución{.}\\
        \end{minipage}.
        .5 \textbf{profile\_results}: \begin{minipage}[t]{8cm}
            resultados de los procesos de <<profiling>>{.}\\
        \end{minipage}.
        .3 \textbf{utilidades}: \begin{minipage}[t]{8cm}
            utilidades (programas) que realizan ciertos pasos de la
            aplicación y de los algoritmos para centralizar estos procedimientos (comunes){.}\\
        \end{minipage}.
        .2 \textbf{docs}: \begin{minipage}[t]{8cm}
            documentación teórica y técnica del proyecto (hecha en \LaTeX){.}\\
        \end{minipage}.
        .3 \textbf{img}: \begin{minipage}[t]{8cm}
            imágenes utilizadas para la generación de la documentación{.}\\
        \end{minipage}.
        .3 \textbf{tex}: \begin{minipage}[t]{8cm}
            archivos de texto plano con código \LaTeX{.}\\
        \end{minipage}.
        .2 \textbf{web}: \begin{minipage}[t]{8cm}
            estructura o código de la aplicación Web{.}\\
        \end{minipage}.
    }
\end{figure}

\begin{figure}[H]
    \dirtree{%
        .1 \textbf{web}: \begin{minipage}[t]{10cm}
            estructura o código de la aplicación Web{.}\\
        \end{minipage}. 
        .2 \textbf{app}: \begin{minipage}[t]{10cm} contiene la
        definición de las rutas, modelos de la base de datos y la
        \texttt{Application Factory} que instancia la aplicación{.}\\
        \end{minipage}.
        .3 \textbf{datasets}: \begin{minipage}[t]{8cm}
            contiene (durante el funcionamiento de la aplicación) todos los conjuntos de
            datos que los usuarios introducen{.}\\
        \end{minipage}.
        .4 \textbf{seleccionar}: \begin{minipage}[t]{8cm}
            conjuntos de datos para seleccionar de prueba, principalmente
            durante el desarrollo de la aplicación{.} También almacena el fichero de
            prueba que los usuarios pueden descargar{.}\\
        \end{minipage}.
        .3 \textbf{static}: \begin{minipage}[t]{10cm}
            ficheros estáticos que utiliza la aplicación Web: CSS,
            Javascript, JSON o imágenes{.}\\
        \end{minipage}.
        .4 \textbf{css}: \begin{minipage}[t]{10cm}
            ficheros CSS{.}\\
        \end{minipage}.
        .4 \textbf{js}: \begin{minipage}[t]{10cm}
            ficheros JavaScript{.}\\
        \end{minipage}.
        .4 \textbf{json}: \begin{minipage}[t]{10cm}
            ficheros JSON{.}\\
        \end{minipage}.
        .4 \textbf{pseudocodigos}: \begin{minipage}[t]{10cm}
            imágenes de los pseudocódigos{.}\\
        \end{minipage}.
        .5 \textbf{en}: \begin{minipage}[t]{10cm}
            imágenes de los pseudocódigos en inglés{.}\\
        \end{minipage}.
        .5 \textbf{es}: \begin{minipage}[t]{10cm}
            imágenes de los pseudocódigos en español{.}\\
        \end{minipage}.
        .3 \textbf{templates}: \begin{minipage}[t]{10cm}
            plantillas HTML (Jinja2) que renderiza la aplicación Web
            (Flask){.}\\
        \end{minipage}.
        .3 \textbf{translations}: \begin{minipage}[t]{10cm}
            traducciones de los textos de la aplicación (por idiomas){.}\\
        \end{minipage}. 
        .2 \textbf{instance}: \begin{minipage}[t]{10cm} contiene
        la base de datos de la aplicación (SQLite){.}\\
            \end{minipage}.
    }
\end{figure}

\section{Manual del programador}
El objetivo de este manual es dar al lector/desarrollador que comience a
trabajar con el proyecto, el conocimiento necesario para continuarlo. Se ha de
tener en cuenta que lo descrito a continuación es lo que se ha utilizado para el
entorno desarrollo inicial y será explicado para este.

En primer lugar se listan las herramientas consideradas para el desarrollo:
\begin{itemize}
    \item Python 3.10: Todo el proyecto, desde su inicio, ha sido desarrollado en la versión 3.10.
    \item Git: Necesario para continuar con el control de versiones del proyecto.
    \item Pycharm: Editor de código utilizado, podría utilizarse otro si así se considerase.
\end{itemize}

Python puede descargarse desde su página principal\footnote{Descargas de
Python: \url{https://www.python.org/downloads/}}. En las herramientas no se ha
mencionado <<pip>> (el administrador de paquetes) pues desde la versión 3.4 de
Python este está instalado con él, sin embargo, sería conveniente asegurarse de
ello comprobado la versión pues en el futuro será necesario. 

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Comprobar pip]
\begin{minted}{shell}
pip --version
python -m ensurepip --upgrade
\end{minted}
\end{tcolorbox}

Y de forma general, comprobar que los binarios pueden ser utilizados por lo
menos en el entorno del programador (en su usuario o equipo completo).

En el caso de Git, desde Linux simplemente se puede realizar con el gestor de
paquetes:

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Instalar Git en Linux]
\begin{minted}{shell}
sudo apt install git-all
\end{minted}
\end{tcolorbox}

Si el entorno es Windows, existe un instalador directo que puede descargarse
desde la página de Git SCM (Source code management)\footnote{Git para Windows:
\url{https://git-scm.com/download/win}}.

Pycharm se puede descargar tanto para Windows como Linux en la página oficial de
JetBrains\footnote{Pycharm: \url{https://www.jetbrains.com/pycharm/download/}}.

\subsection{Comprensión de la estructura}

Se recomienda leer la sección anterior donde se pueden consultar todos los
directorios del proyecto con una breve descripción. La preparación del entorno
virtual con el que trabajar se explicará en la próxima sección.

El proyecto se desarrolla en dos ramas comunicadas (de forma unidireccional):
los algoritmos implementados y la aplicación Web. La aplicación es la que
utiliza los algoritmos para obtener la información presentada en la Web.

\paragraph{Algoritmos semi-supervisados} (contenidos en el directorio algoritmos):
Los algoritmos desarrollados y nuevos han de situarse en este directorio como
raíz. La idea es que cada fichero <<.py>>, homónimo al algoritmo, contenga la
definición de un objeto que encapsule el desarrollo del mismo, para que no haya
confusión.

Estructura de los objetos (mínima):

\textbf{Constructor}: Donde se configuran los parámetros que necesita el algoritmo. Es
recomendable realizar una validación de los mismos por si fueran utilizados de manera individual.

\textbf{Método de entrenamiento (Fit)}: Dado que estos algoritmos están pensados no solo
para entrenar, sino para almacenar el proceso de entrenamiento y estadísticas,
siempre ha de recibir el conjunto de entrenamiento (x, y), el conjunto de test
(x\_test, y\_test) y el nombre de las características de cada instancia.

En principio, el método de desarrollo seguido es el de primero implementar el
algoritmo para después añadir, con la librería Pandas, un registro completo de
los momentos de etiquetado y de las estadísticas de cada iteración.

Este método deberá retornar el registro de etiquetado, el estadístico y el
número de iteraciones realizadas.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera fit]
\begin{minted}{python}
def fit(x, y, x_test, y_test, features)
\end{minted}
\end{tcolorbox}

Es importante tener en cuenta que esta estructura puede variar en la medida de
cómo sea el algoritmo. Por ejemplo, en el caso de Democratic Co-Learning se
hacía imprescindible añadir estadísticas específicas para cada clasificador que
encapsula y por tanto, retornaba más elementos.

\textbf{Método de predicción}: En el caso de algoritmos que trabajan con un único
clasificador podría ser opcional, pero en el caso de varios, es necesario
considerar cómo se predicen las etiquetas en combinación.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera predict]
\begin{minted}{python}
def predict(self, instances)
\end{minted}
\end{tcolorbox}
    

\textbf{Métodos estadísticos}: Dependiendo de lo que se desee mostrar en la
aplicación, se incluirán ciertas estadísticas.

La convención utilizada hasta ahora es crear un método que comience por <<get\_>>
seguido del nombre de la estadística, por ejemplo \texttt{get\_accuracy\_score}.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera ejemplo estadística]
\begin{minted}{python}
def get_accuracy_score(self, x_test, y_test):
\end{minted}
\end{tcolorbox}

\paragraph{Utilidades} En el directorio de las utilidades se han de alojar
aquellos métodos que se reutilizan en el proyecto (y que intervenga algún paso
del algoritmo, por ejemplo, la carga de datos). 

\paragraph{Tests} El desarrollo del software debe ser validado para asegurar su
correcto funcionamiento ante las distintas casuísticas. Cuando se desarrolla
código en esta sección, sus casos de prueba codificados deben incluirse en el
directorio correspondiente. Se utiliza <<pytest>> como \textit{framework} de
pruebas.

\paragraph{Aplicación Web} (contenida en el directorio web):  

La aplicación está desarrollada con el <<micro-framework>> Flask, que permite la
creación de aplicaciones Web en Python. A lo largo del desarrollo la estructura
de la aplicación ha variado bastante. Finalmente, se ha modularizado
completamente con el uso de \texttt{Blueprints} y una \texttt{Application
Factory} que se encarga de instancia la aplicación, base de datos y pone en
funcionamiento las distintas rutas accesibles.

\textbf{run.py}: Centraliza la ejecución de la aplicación (mediante la
\texttt{Application Factory}) 

\textbf{instance}: Donde se almacena la instancia de la base de datos.

\textbf{app}: Este directorio contiene toda la
definición de la aplicación, el resto de los apartados comentados siguientes se
encuentran dentro de este.

El fichero \texttt{\_\_init\_\_.py} contiene la creación de la aplicación con un
método \texttt{create\_app} (\texttt{Application Factory}). Aquí se específica
toda la configuración, los elementos comunes (como los filtros de Jinja), se
instancia la base de datos y se registran las rutas (organizadas con
\texttt{Blueprints} como paquetes o extensiones de la aplicación básica).

\textbf{Blueprints}: Las rutas que tiene la aplicación están organizadas en
función de su categoría mediante los Blueprints. Y es en los ficheros que
terminan por <<\_routes.py>> donde se definen. Si se añade una categoría nueva se
debe crear un Blueprint la identifique dentro de su fichero y después debe ser
registrado en la aplicación (en \texttt{\_\_init\_\_.py}).

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Crear Blueprint]
\begin{minted}{python}
# El nombre es a elección propia
nuevo_bp = Blueprint('nuevo_bp', __name__)
\end{minted}
\end{tcolorbox}

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Registrar Blueprint]
\begin{minted}{python}
# Seleccionando el prefijo deseado
app.register_blueprint(nuevo_bp, url_prefix='/') 
\end{minted}
\end{tcolorbox}

La visualización de un algoritmo se centra en dos pasos: la configuración del
mismo (en las rutas \texttt{/configuracion/<algoritmo>}) donde se debe
renderizar una página con el formulario de configuración (gestionado por
\texttt{configuration\_routes.py}), y la visualización
(\texttt{/visualizacion/<algoritmo>}) donde se renderiza la página donde se
encuentran todos los gráficos de los algoritmos (gestionado por
\texttt{visualization\_routes.py}). Además, existe un paso intermedio en el que
se obtienen los datos de la ejecución de los algoritmos, este paso no es una
ruta que pueda visualizarse (gestionado por \texttt{data\_routes.py}),
es un método auxiliar que accede el propio usuario (su navegador) para obtener
la información. Por lo general, la convención utilizada es que todos los métodos
y rutas lleven el nombre del algoritmo.

\textbf{Plantillas (templates)}: Flask utiliza el motor de plantillas Jinja2, que añaden
instrucciones en HTML. Obviando que cada algoritmo tiene sus particularidades,
están organizadas mediante la extensión de plantillas. De forma general, añadir
un algoritmo podría solo intervenir la creación de una plantilla de
configuración y otra de visualización. En ambos casos se tiene una plantilla
base de la que se debe extender.

\textbf{Ficheros estáticos (static)}: El contenido dinámico debe ser creado mediante
Javascript, de forma <<vanilla>> (sin utilizar frameworks). En menor medida, los
estilos deben ser retocados en estos ficheros aunque en principio la aplicación
está estilada con Bootstrap 5.

En estos ficheros estáticos se tienen unas imágenes con los pseudocódigos de los
algoritmos. Estas imágenes deben verse tanto en la configuración como la
visualización.

Otra parte muy importante es si se quieren añadir nuevos clasificadores base con
sus parámetros, estos están almacenados en el fichero JSON <<parametros.json>>.
Hasta el momento del desarrollo solo existen dos tipos de entradas, los
selectores y los numéricos.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Estructura para añadir clasificadores y sus parámetros]
\begin{minted}{json}
{
    "ClasificadorBase": {
        "parametro_numerico": {
        "label": "Nombre a mostrar",
        "type": "number",
        "step": 1,
        "min": 1,
        "max": "Infinity",
        "default": 5
        },
        "parametro_selector": {
        "label": "Nombre a mostrar",
        "type": "select",
        "options": ["lista", "de", "elementos"],
        "default": "elementos"
        }
    }
}
\end{minted}
\end{tcolorbox}

Con <<step>> se debe tener en cuenta la posibilidad de permitir números enteros
(al introducir 1) o números decimales (al incluir un flotante, por ejemplo, 0.01)

\textbf{Conjunto de datos (datasets)}: Los conjuntos de datos de los usuarios (vinculados a
sus sesiones) se almacenan localmente en la aplicación con el <<Timestamp>>
concatenado el nombre del fichero introducido.

\textbf{Internacionalización}: La aplicación está pensada para ser
internacionalizada en cualquier idioma, aunque solo se ha incluido inglés y
español. Una de las herramientas utilizadas es Babel, para incluir nuevo texto
en la aplicación se debe utilizar la función \texttt{gettext()} (tanto en Jinja2
como Python si fuera necesario). El proceso de compilación está explicado en la
siguiente sección.

\section{Compilación, instalación y ejecución del proyecto}

Para poner en funcionamiento la aplicación primero se debe preparar su entorno
de ejecución. Se recuerda la necesidad de tener instalado Python (con el administrador de
paquetes <<pip>>).

\paragraph{Código fuente de la aplicación} Para obtener el código fuente de la
aplicación, este debe ser descargado del repositorio Github utilizado\footnote{
Repositorio: \url{https://github.com/dma1004/TFG-SemiSupervisado}}.

Tanto en Windows como en Linux esto se puede realizar descargando el fichero
comprimido de todo el repositorio desde el navegador.

Pero si se quiere realizar mediante consola de comandos, y suponiendo que se ha
instalado Git:

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,fontupper=\footnotesize,title=Clonación de repositorio desde consola]
\begin{minted}{shell}
$ git clone https://github.com/dma1004/TFG-SemiSupervisado.git
\end{minted}
\end{tcolorbox}
La localización del proyecto queda a discreción del programador.

\paragraph{Entorno virtual Python} El entorno virtual no es estrictamente
necesario aunque es \textbf{altamente} recomendable, pues en los próximos pasos
se instalarán múltiples librerías que sin entorno virtual quedarían instaladas
globalmente.

El proceso descrito a continuación puede ser sustituido en caso de que solo se
esté trabajando con Pycharm. Este editor permite crear entornos virtuales e
incluso realizarlo automáticamente al detectar los distintos requisitos del
proyecto. Pero de forma general, suponiendo que se desea preparar un entorno de
<<pruebas>> o <<producción>> y que la aplicación esté en funcionamiento, se
realizan los siguientes pasos:

\begin{tcolorbox}[colback=cyan!5!white,colframe=orange!75!black,title=Creación del entorno virtual (dentro de la carpeta deseado)]
\begin{minted}{shell}
$ python -m venv ./venv
\end{minted}
\end{tcolorbox}


\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,fontupper=\footnotesize,fontlower=\footnotesize,title=Activación del entorno virtual]
\begin{minted}{matlab}
$ venv\activate.bat //Windows
\end{minted}
\tcblower
\begin{minted}{matlab}
$ source ruta/al/entorno/virtual/bin/activate //Linux
\end{minted}
\end{tcolorbox}

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Para desactivar el entorno (una vez en él)]
\begin{minted}{shell}
$ deactivate
\end{minted}
\end{tcolorbox}

\paragraph{Instalación de paquetes} En este paso se van a instalar todas las
librerías necesarias, el proyecto trae un fichero <<requirements.txt>> en el que
vienen especificados estos paquetes y sus versiones. Además, los algoritmos
implementados también están configurados como un paquete que puede ser
instalado.

\begin{tcolorbox}[colback=cyan!5!white,colframe=orange!75!black,title=Instalar librerías externas]
\begin{minted}{shell}
$ python -m pip install -r requierements.txt
\end{minted}
\end{tcolorbox}

\begin{tcolorbox}[colback=cyan!5!white,colframe=orange!75!black,title=Instalar paquete de algoritmos]
\begin{minted}{shell}
$ python -m pip install .
\end{minted}
\end{tcolorbox}

A partir de aquí ya se tiene configurado todo el entorno y los requisitos necesarios para poder ejecutar la aplicación.

\paragraph{Ejecución} Referida a la ejecución de la aplicación Web (Flask), se
debe estar situado en el directorio \textbf{/web} del proyecto.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,fontupper=\footnotesize,fontlower=\footnotesize,title=Ejecución]
\begin{minted}{shell}
$ set FLASK_APP=app.py //Windows
$ flask run
\end{minted}
\tcblower
\begin{minted}{shell}
$ flask run //Linux
\end{minted}
\end{tcolorbox}

Existe una última cuestión que no es estrictamente necesaria para funcionar, pero
que añade la internacionalización a la aplicación automáticamente.

\paragraph{Internacionalización} En el caso de que se haya incluido más texto
traducido, este debe ser compilado con Babel para que la aplicación pueda
detectarlo.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,fontupper=\footnotesize,title=Proceso de internacionalización (desde /web)]
\begin{minted}{shell}
Extraer los texto encapsulados por gettext
$ pybabel extract -F babel.cfg -o messages.pot . 

Actualizar los textos extraidos en el fichero de compilación
$ pybabel update -i messages.pot -d translations

Compilación de las traducciones
$ pybabel compile -d translations 
\end{minted}
\end{tcolorbox}
 
A partir de aquí la propia aplicación utilizará las traducciones dependiendo del
usuario que acceda.

\clearpage
\section{Pruebas del sistema}
