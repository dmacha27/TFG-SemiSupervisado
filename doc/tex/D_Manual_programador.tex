\apendice{Documentación técnica de programación}

\section{Introducción}
En esta sección se presenta toda la documentación técnica del desarrollo del
proyecto. Trata de ser una guía para entender cómo se ha hecho el proyecto
comenzando por los directorios y su contenido, con un manual introductorio para
un programador iniciado en el proyecto, explicación y ejemplificación de la
instalación del mismo y las pruebas que se han realizado para validarlo.

\section{Estructura de directorios}
Estos son los directorios en los que se organiza el proyecto:

\begin{figure}[H]
    \dirtree{% 
        .1 /.
        .2 \textbf{algoritmos}: \begin{minipage}[t]{8cm}
            algoritmos Semi-Supervisados implementados{.}\\
        \end{minipage}.
        .3 \textbf{test}: \begin{minipage}[t]{8cm}
            directorios y ficheros mediante los que se valida el
            desarrollo software correcto del proyecto{.}\\
        \end{minipage}.
        .4 \textbf{check\_implementations}: \begin{minipage}[t]{8cm}
            pruebas para la validación de los algoritmos{.}\\
        \end{minipage}.
        .5 \textbf{results}: \begin{minipage}[t]{8cm}
            ficheros CSV con resultados de validación cruzada{.}\\
        \end{minipage}.
        .4 \textbf{profile\_results}: \begin{minipage}[t]{8cm}
            resultados de los procesos de <<profiling>>{.}\\
        \end{minipage}.
        .4 \textbf{test\_files}: \begin{minipage}[t]{8cm}
            ficheros de prueba (ARFF y CSV) para las pruebas{.}\\
        \end{minipage}.
        .3 \textbf{utilidades}: \begin{minipage}[t]{8cm}
            utilidades (programas) que realizan ciertos pasos de la
            aplicación y de los algoritmos para centralizar estos procedimientos (comunes){.}\\
        \end{minipage}.
        .2 \textbf{docs}: \begin{minipage}[t]{8cm}
            documentación teórica y técnica del proyecto (hecha en \LaTeX){.}\\
        \end{minipage}.
        .3 \textbf{img}: \begin{minipage}[t]{8cm}
            imágenes utilizadas para la generación de la documentación{.}\\
        \end{minipage}.
        .3 \textbf{tex}: \begin{minipage}[t]{8cm}
            archivos de texto plano con código \LaTeX{.}\\
        \end{minipage}.
        .2 \textbf{web}: \begin{minipage}[t]{8cm}
            estructura o código de la aplicación Web{.}\\
        \end{minipage}.
        .3 \textbf{datasets}: \begin{minipage}[t]{8cm}
            contiene (durante el funcionamiento de la aplicación) todos los conjuntos de
            datos que los usuarios introducen{.}\\
        \end{minipage}.
        .4 \textbf{seleccionar}: \begin{minipage}[t]{8cm}
            conjuntos de datos para seleccionar de prueba, principalmente
            durante el desarrollo de la aplicación{.} También almacena el fichero de
            prueba que los usuarios pueden descargar{.}\\
        \end{minipage}.
    }
\end{figure}

\begin{figure}[H]
    \dirtree{%
        .1 \textbf{web}: \begin{minipage}[t]{10cm}
            estructura o código de la aplicación Web{.}\\
        \end{minipage}.
        .2 \textbf{static}: \begin{minipage}[t]{10cm}
            ficheros estáticos que utiliza la aplicación Web: CSS,
            Javascript o JSON{.}\\
        \end{minipage}.
        .2 \textbf{templates}: \begin{minipage}[t]{10cm}
            plantillas HTML (Jinja2) que renderiza la aplicación Web
            (Flask){.}\\
        \end{minipage}.
        .2 \textbf{translations}: \begin{minipage}[t]{10cm}
            traducciones de los textos de la aplicación (por idiomas){.}\\
        \end{minipage}.
    }
\end{figure}

\section{Manual del programador}
El objetivo de este manual es dar al lector/desarrollador que comience a
trabajar con el proyecto el conocimiento necesario para continuarlo. Se ha de
tener en cuenta que lo descrito a continuación es lo que se ha utilizado para el
entorno desarrollo inicial y será explicado para este.

En primer lugar se listan las herramientas consideradas para el
desarrollo:
\begin{itemize}
    \item Python 3.10: Todo el proyecto, desde su inicio, ha sido desarrollado en la versión 3.10.
    \item Git: Necesario para continuar con el control de versiones del proyecto.
    \item Pycharm: Editor de código utilizado, podría utilizarse otro si así se considerase.
\end{itemize}

Python puede descargarse desde su página principal\footnote{Descargas de
Python: \url{https://www.python.org/downloads/}}. En las herramientas no se ha
mencionado <<pip>> (el administrador de paquetes) pues desde la versión 3.4 de
Python este está instalado con él, sin embargo, sería conveniente asegurarse de
ello comprobado la versión pues en el futuro será necesario. 

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Comprobar pip]
\begin{minted}{shell}
pip --version
python -m ensurepip --upgrade
\end{minted}
\end{tcolorbox}

Y de forma general, comprobar que los binarios pueden ser utilizados por lo
menos en el entorno del programador (en su usuario o equipo completo).

En el caso de Git, desde Linux simplemente se puede realizar con el gestor de
paquetes:

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Instalar Git en Linux]
\begin{minted}{shell}
sudo apt install git-all
\end{minted}
\end{tcolorbox}

Si el entorno es Windows existe un instalador directo que puede descargarse
desde la página de Git SCM (Source code management)\footnote{Git para Windows:
\url{https://git-scm.com/download/win}}.

Pycharm se puede descargar tanto para Windows como Linux en la página oficial de
JetBrains\footnote{Pycharm: \url{https://www.jetbrains.com/pycharm/download/}}.

\subsection{Comprensión de la estructura}

Se recomienda leer la sección anterior donde se pueden consultar todos los
directorios del proyecto con una breve descripción. La preparación del entorno
virtual con el que trabajar se explicará en la próxima sección.

El proyecto se desarrolla en dos ramas comunicadas (de forma unidireccional):
los algoritmos implementados y la aplicación Web. La aplicación es la que
utiliza los algoritmos para obtener la información presentada en la Web.

\paragraph{Algoritmos semi-supervisados} (contenidos en el directorio algoritmos):
Los algoritmos desarrollados y nuevos han de situarse en este directorio como
raíz. La idea es que cada fichero <<.py>>, homónimo al algoritmo, contenga la
definición de un objeto que encapsule el desarrollo del mismo, para que no haya
confusión.

Estructura de los objetos (mínima):

\textbf{Constructor}: Donde se configuran los parámetros que necesita el algoritmo. Es
recomendable realizar una validación de los mismos por si fueran utilizados de manera individual.

\textbf{Método de entrenamiento (Fit)}: Dado que estos algoritmos están pensados no solo
para entrenar sino para almacenar el proceso de entrenamiento y estadísticas,
siempre ha de recibir el conjunto de entrenamiento (x, y), el conjunto de test
(x\_test, y\_test) y el nombre de las características de cada instancia.

En principio, el método de desarrollo seguido es el de primero implementar el
algoritmo para después añadir, con la librería Pandas, un registro completo de
los momentos de etiquetado y de las estadísticas de cada iteración.

Este método deberá retornar el registro de etiquetado, el estadístico y el
número de iteraciones realizadas.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera fit]
\begin{minted}{python}
def fit(x, y, x_test, y_test, features)
\end{minted}
\end{tcolorbox}

Es importante tener en cuenta que esta estructura puede variar en la medida de
cómo sea el algoritmo. Por ejemplo, en el caso de Democratic Co-Learning se
hacía imprescindible añadir estadísticas específicas para cada clasificador que
encapsula y por tanto, retornaba más elementos.

\textbf{Método de predicción}: En el caso de algoritmos que trabajan con un único
clasificador podría ser opcional, pero en el caso de varios, es necesario
considerar cómo se predicen las etiquetas en combinación.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera predict]
\begin{minted}{python}
def predict(self, instances)
\end{minted}
\end{tcolorbox}
    

\textbf{Métodos estadísticos}: Dependiendo de lo que se desee mostrar en la
aplicación, se incluirán ciertas estadísticas.

La convención utilizada hasta ahora es crear un método que comience por <<get\_>>
seguido del nombre de la estadística, por ejemplo get\_accuracy\_score.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera ejemplo estadística]
\begin{minted}{python}
def get_accuracy_score(self, x_test, y_test):
\end{minted}
\end{tcolorbox}

\paragraph{Utilidades} En el directorio de las utilidades se han de alojar
aquellos métodos que se reutilizan en el proyecto (y que intervenga algún paso
del algoritmo, por ejemplo, la carga de datos). 

\paragraph{Tests}, el desarrollo del software debe ser validado para asegurar su
correcto funcionamiento antes las distintas casuísticas. Cuando se desarrolla
código en esta sección, sus casos de prueba codificados deben incluirse en el
directorio correspondiente. Se utiliza <<pytest>> como \textit{framework} de
pruebas.


\paragraph{Aplicación Web} (contenida en el directorio web):  


\section{Compilación, instalación y ejecución del proyecto}

\section{Pruebas del sistema}
