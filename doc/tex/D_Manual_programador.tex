\apendice{Documentación técnica de programación}

\section{Introducción}
En esta sección se presenta toda la documentación técnica del desarrollo del
proyecto. Trata de ser una guía para entender cómo se ha hecho el proyecto
comenzando por los directorios y su contenido, con un manual introductorio para
un programador que es iniciado en el proyecto, una explicación y ejemplificación de la
instalación del mismo y las pruebas que se han realizado para validarlo.

\tcbset{colback=red!5!white,fonttitle=\bfseries}
\begin{tcolorbox}[enhanced,title=Repositorio Github,
frame style={left color=blue!75!black,
right color=cyan!75!black}]
\url{https://github.com/dma1004/TFG-SemiSupervisado}
\end{tcolorbox}

\section{Estructura de directorios}
Estos son los directorios en los que se organiza el proyecto:

\begin{figure}[H]
    \dirtree{% 
        .1 /.
        .2 \textbf{algoritmos}: \begin{minipage}[t]{8cm}
            algoritmos Semi-Supervisados implementados{.}\\
        \end{minipage}.
        .3 \textbf{test}: \begin{minipage}[t]{8cm}
            directorios y ficheros mediante los que se valida el
            desarrollo software correcto del proyecto{.}\\
        \end{minipage}.
        .4 \textbf{check\_implementations}: \begin{minipage}[t]{6cm}
            pruebas para la validación de los algoritmos{.}\\
        \end{minipage}.
        .5 \textbf{results}: \begin{minipage}[t]{8cm}
            ficheros CSV con resultados de validación cruzada{.}\\
        \end{minipage}.
        .4 \textbf{check\_utils}: \begin{minipage}[t]{8cm}
            pruebas para la validación de las utilidades{.}\\
        \end{minipage}.
        .5 \textbf{test\_files}: \begin{minipage}[t]{8cm}
            ficheros de prueba (ARFF y CSV) para las pruebas{.}\\
        \end{minipage}.
        .4 \textbf{profiling}: \begin{minipage}[t]{8cm}
            pruebas para medir el tiempo de ejecución{.}\\
        \end{minipage}.
        .5 \textbf{profile\_results}: \begin{minipage}[t]{8cm}
            resultados de los procesos de <<profiling>>{.}\\
        \end{minipage}.
        .3 \textbf{utilidades}: \begin{minipage}[t]{8cm}
            utilidades (programas) que realizan ciertos pasos de la
            aplicación y de los algoritmos para centralizar estos procedimientos (comunes){.}\\
        \end{minipage}.
        .2 \textbf{docs}: \begin{minipage}[t]{8cm}
            documentación teórica y técnica del proyecto (hecha en \LaTeX){.}\\
        \end{minipage}.
        .3 \textbf{img}: \begin{minipage}[t]{8cm}
            imágenes utilizadas para la generación de la documentación{.}\\
        \end{minipage}.
        .3 \textbf{tex}: \begin{minipage}[t]{8cm}
            archivos de texto plano con código \LaTeX{.}\\
        \end{minipage}.
        .2 \textbf{web}: \begin{minipage}[t]{8cm}
            estructura o código de la aplicación Web{.}\\
        \end{minipage}.
    }
\end{figure}

\begin{figure}[H]
    \dirtree{%
        .1 \textbf{web}: \begin{minipage}[t]{10cm}
            estructura o código de la aplicación Web{.}\\
        \end{minipage}. 
        .2 \textbf{app}: \begin{minipage}[t]{10cm} contiene la
        definición de las rutas, modelos de la base de datos y la
        \texttt{Application Factory} que instancia la aplicación{.}\\
        \end{minipage}.
        .3 \textbf{datasets}: \begin{minipage}[t]{8cm}
            contiene (durante el funcionamiento de la aplicación) todos los conjuntos de
            datos que los usuarios introducen{.}\\
        \end{minipage}.
        .4 \textbf{anonimos}: \begin{minipage}[t]{8cm}
            conjuntos de datos subidos por los usuarios anónimos{.}\\
        \end{minipage}.
        .4 \textbf{registrados}: \begin{minipage}[t]{8cm}
            conjuntos de datos subidos por los usuarios registrados{.}\\
        \end{minipage}.
        .4 \textbf{seleccionar}: \begin{minipage}[t]{8cm}
            conjuntos de datos para seleccionar de prueba, principalmente
            durante el desarrollo de la aplicación{.} También almacena el fichero de
            prueba que los usuarios pueden descargar{.}\\
        \end{minipage}.
        .3 \textbf{runs}: \begin{minipage}[t]{8cm}
            contiene las ejecuciones de los algoritmos en formato JSON, 
            solo de los usuarios registrados{.}\\
        \end{minipage}.
        .3 \textbf{static}: \begin{minipage}[t]{10cm}
            ficheros estáticos que utiliza la aplicación Web: CSS,
            Javascript, JSON o imágenes{.}\\
        \end{minipage}.
        .4 \textbf{css}: \begin{minipage}[t]{10cm}
            ficheros CSS{.}\\
        \end{minipage}.
        .4 \textbf{js}: \begin{minipage}[t]{10cm}
            ficheros JavaScript{.}\\
        \end{minipage}.
        .5 \textbf{configuracion}: \begin{minipage}[t]{10cm}
            ficheros JavaScript encargados de la configuración de la ejecución de los algoritmos{.}\\
        \end{minipage}.
        .5 \textbf{usuarios}: \begin{minipage}[t]{10cm}
            ficheros JavaScript encargados de la generación de tablas y control del espacio personal de los usuarios y el panel de administración{.}\\
        \end{minipage}.
        .5 \textbf{visualizacion}: \begin{minipage}[t]{10cm}
            ficheros JavaScript encargados de la inicialización y generación de los gráficos en la visualización (gráfico principal y estadísticas){.}\\
        \end{minipage}.
    }
\end{figure}


\begin{figure}[H]
    \dirtree{%
        .1 \textbf{web}: \begin{minipage}[t]{10cm}
            estructura o código de la aplicación Web{.}\\
        \end{minipage}. 
        .2 \textbf{app}: \begin{minipage}[t]{10cm} contiene la
        definición de las rutas, modelos de la base de datos y la
        \texttt{Application Factory} que instancia la aplicación{.}\\
        \end{minipage}.
        .3 \textbf{static}: \begin{minipage}[t]{10cm}
            ficheros estáticos que utiliza la aplicación Web: CSS,
            Javascript, JSON o imágenes{.}\\
        \end{minipage}.
        .4 \textbf{css}: \begin{minipage}[t]{10cm}
            ficheros CSS{.}\\
        \end{minipage}.
        .4 \textbf{js}: \begin{minipage}[t]{10cm}
            ficheros JavaScript{.}\\
        \end{minipage}.
        .4 \textbf{json}: \begin{minipage}[t]{10cm}
            ficheros JSON{.}\\
        \end{minipage}.
        .4 \textbf{pseudocodigos}: \begin{minipage}[t]{10cm}
            imágenes de los pseudocódigos{.}\\
        \end{minipage}.
        .5 \textbf{en}: \begin{minipage}[t]{10cm}
            imágenes de los pseudocódigos en inglés{.}\\
        \end{minipage}.
        .5 \textbf{es}: \begin{minipage}[t]{10cm}
            imágenes de los pseudocódigos en español{.}\\
        \end{minipage}.
        .3 \textbf{templates}: \begin{minipage}[t]{10cm}
            plantillas HTML (Jinja2) que renderiza la aplicación Web
            (Flask){.}\\
        \end{minipage}.
        .4 \textbf{configuracion}: \begin{minipage}[t]{10cm}
            plantillas concretas de la ventana de configuración de la ejecución de los algoritmos{.}\\
        \end{minipage}.
        .4 \textbf{usuarios}: \begin{minipage}[t]{10cm}
            plantillas concretas de las distintas ventanas de los usuarios: login, registro, perfil, espacio personal y panel de administración{.}\\
        \end{minipage}.
        .4 \textbf{visualizacion}: \begin{minipage}[t]{10cm}
            plantillas concretas de las distintas ventanas de visualización de los algoritmos{.}\\
        \end{minipage}.
        .3 \textbf{translations}: \begin{minipage}[t]{10cm}
            traducciones de los textos de la aplicación (por idiomas){.}\\
        \end{minipage}. 
        .2 \textbf{instance}: \begin{minipage}[t]{10cm} contiene
        la base de datos de la aplicación (SQLite){.}\\
            \end{minipage}.
    }
\end{figure}

\section{Manual del programador}
El objetivo de este manual es dar el conocimiento necesario al 
lector/desarrollador que comience a trabajar con este proyecto para continuarlo . Se ha de
tener en cuenta que lo descrito a continuación es lo que se ha estado utilizando 
para el entorno desarrollo inicial y será explicado para este (sin limitación, por ejemplo,
a usar otras herramientas).

En primer lugar se listan las herramientas consideradas para el desarrollo:
\begin{itemize}
    \item Python 3.10: Todo el proyecto, desde su inicio, ha sido desarrollado en la versión 3.10.
    \item Git: Necesario para continuar con el control de versiones del proyecto.
    \item Pycharm: Editor de código utilizado, podría utilizarse otro si así se considerase.
\end{itemize}

Python puede descargarse desde su página principal\footnote{Descargas de
Python: \url{https://www.python.org/downloads/}}. En las herramientas no se ha
mencionado <<pip>> (el administrador de paquetes) pues desde la versión 3.4 de
Python este está instalado con él, sin embargo, sería conveniente asegurarse de
ello comprobado la versión pues en el futuro será necesario. 

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Comprobar pip]
\begin{minted}{shell}
pip --version 
python -m ensurepip --upgrade
\end{minted}
\end{tcolorbox}

Y de forma general, comprobar que los ficheros binarios pueden ser utilizados por lo
menos, en el entorno del programador (solo en la cuenta del usuario o en el equipo completo).

En el caso de Git, desde Linux simplemente se puede instalar con su gestor de
paquetes:

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Instalar Git en Linux]
\begin{minted}{shell}
sudo apt install git-all
\end{minted}
\end{tcolorbox}

Si el entorno es Windows, existe un instalador directo que puede descargarse
desde la página de Git SCM (Source code management)\footnote{Git para Windows:
\url{https://git-scm.com/download/win}}.

Pycharm se puede descargar tanto para Windows como Linux en la página oficial de
JetBrains\footnote{Pycharm: \url{https://www.jetbrains.com/pycharm/download/}}.

\subsection{Comprensión de la estructura}

Se recomienda leer la sección anterior donde se pueden consultar todos los
directorios del proyecto con una breve descripción. La preparación del entorno
virtual con el que trabajar se explicará en la próxima sección.

El proyecto se desarrolla en dos ramas comunicadas (de forma unidireccional):
los algoritmos implementados y la aplicación Web. La aplicación es la que
utiliza los algoritmos para obtener la información presentada en la Web.

\paragraph{Algoritmos semi-supervisados} (contenidos en el directorio
\texttt{algoritmos}): Los algoritmos desarrollados y nuevos han de situarse en
este directorio como raíz. La idea es que cada fichero <<.py>>, homónimo al
algoritmo, contenga la definición de un objeto que encapsule el desarrollo del
mismo, para que no haya confusión.

Estructura de los objetos (mínima):

\textbf{Constructor}: Donde se configuran los parámetros que necesita el algoritmo. Es
recomendable realizar una validación de los mismos por si fueran utilizados de manera individual.

\textbf{Método de entrenamiento (Fit)}: Dado que estos algoritmos están pensados
no solo para entrenar, sino para almacenar el proceso de entrenamiento y
estadísticas, siempre ha de recibir el conjunto de entrenamiento ($\mathbf{x}$,
$y$), el conjunto de test (\texttt{x\_test}, \texttt{y\_test}) y el nombre de
las características de cada instancia (el nombre de las columnas de
$\mathbf{x}$).

En principio, el método de desarrollo seguido es el de primero implementar el
algoritmo para después añadir, con la librería Pandas, un registro completo de
los momentos de etiquetado y de las estadísticas de cada iteración.

Este método deberá retornar el registro de etiquetado, el registro estadístico y el
número de iteraciones realizadas.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera fit]
\begin{minted}{python}
def fit(x, y, x_test, y_test, features)
\end{minted}
\end{tcolorbox}

Es importante tener en cuenta que esta estructura puede variar en la medida de
cómo sea el algoritmo. Por ejemplo, en el caso de Democratic Co-Learning se
hacía imprescindible añadir estadísticas específicas para cada clasificador que
encapsula y por tanto, retornaba más elementos.

\textbf{Método de predicción}: En el caso de algoritmos que trabajan con un único
clasificador podría ser opcional, pero en el caso de varios, es necesario
considerar cómo se predicen las etiquetas en combinación.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera predict]
\begin{minted}{python}
def predict(self, instances)
\end{minted}
\end{tcolorbox}
    

\textbf{Métodos estadísticos}: Dependiendo de lo que se desee mostrar en la
aplicación, se incluirán ciertas estadísticas.

La convención utilizada hasta ahora es crear un método que comience por
<<\texttt{get\_}>> seguido del nombre de la estadística, por ejemplo
\texttt{get\_accuracy\_score}.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Cabecera ejemplo estadística]
\begin{minted}{python}
def get_accuracy_score(self, x_test, y_test):
\end{minted}
\end{tcolorbox}

\paragraph{Utilidades} En el directorio de las utilidades se han de alojar
aquellos métodos que se reutilizan en el proyecto (y que intervenga en algún paso
del algoritmo, como por ejemplo, la carga de datos). 

\paragraph{Test} El desarrollo del software debe ser validado para asegurar su
correcto funcionamiento ante las distintas casuísticas. Cuando se desarrolla
código en esta sección, sus casos de prueba codificados deben incluirse en el
directorio correspondiente. Se utiliza <<pytest>> como \textit{framework} de
pruebas.

\paragraph{Aplicación Web} (contenida en el directorio \texttt{web}):  

La aplicación está desarrollada con el <<micro-framework>> Flask, que permite la
creación de aplicaciones Web en Python. A lo largo del desarrollo la estructura
de la aplicación ha variado bastante. Finalmente, se ha modularizado
completamente con el uso de \texttt{Blueprints} y una \texttt{Application
Factory} que se encarga de instancia la aplicación, base de datos y pone en
funcionamiento las distintas rutas accesibles.

\textbf{\texttt{run.py}}: Centraliza la ejecución de la aplicación (mediante la
\texttt{Application Factory}) 

\textbf{\texttt{instance}}: Donde se almacena la instancia de la base de datos.

\textbf{\texttt{app}}: Este directorio contiene toda la definición de la
aplicación, el resto de los apartados comentados siguientes se encuentran dentro
de este.

El fichero \texttt{\_\_init\_\_.py} contiene la creación de la aplicación con un
método \texttt{create\_app} (\texttt{Application Factory}). Aquí se específica
toda la configuración, los elementos comunes (como los filtros de Jinja), se
instancia la base de datos y se registran las rutas (organizadas con
\texttt{Blueprints} como paquetes o extensiones de la aplicación básica).

\textbf{Blueprints}: Las rutas que tiene la aplicación están organizadas en
función de su categoría mediante los Blueprints. Y es en los ficheros que
terminan por <<\_routes.py>> donde se definen. Si se añade una categoría nueva
se debe crear un Blueprint que la identifique dentro de su fichero y después
debe ser registrado en la aplicación (en \texttt{\_\_init\_\_.py}).

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Crear Blueprint]
\begin{minted}{python}
# El nombre es a elección propia
nuevo_bp = Blueprint('nuevo_bp', __name__)
\end{minted}
\end{tcolorbox}

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Registrar Blueprint en la aplicación (en \texttt{\_\_init\_\_.py})] 
\begin{minted}{python}
# Seleccionando el prefijo deseado
app.register_blueprint(nuevo_bp, url_prefix='/') 
\end{minted}
\end{tcolorbox}

\textbf{Modelos de la base de datos}: En <<models.py>> se tienen definidas todas
las entidades que maneja la aplicación: \texttt{Users}, \texttt{Datasets} y
\texttt{Runs}. Si se desea añadir alguna, primero se debe crear aquí la
definición de la misma. Para que la aplicación sepa las entidades que debe
manejar, también es necesario importarla en la creación de la aplicación.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Importar modelo (en <<create\_app()>> de \texttt{\_\_init\_\_.py})]
    \begin{minted}{python}
    from .models import Nueva
    \end{minted}
\end{tcolorbox}

La \textbf{visualización de un algoritmo} se centra en dos pasos: la
configuración del mismo (en las rutas \texttt{/configuracion/<algoritmo>}) donde
se debe renderizar una página con el formulario de configuración (gestionado por
\texttt{configuration\_routes.py}), y la visualización
(\texttt{/visualizacion/<algoritmo>}) donde se renderiza la página donde se
encuentran todos los gráficos de los algoritmos (gestionado por
\texttt{visualization\_routes.py}). Además, existe un paso intermedio en el que
se obtienen los datos de la ejecución de los algoritmos, este paso no es una
ruta que pueda visualizarse (gestionado por \texttt{data\_routes.py}), es un
método auxiliar que accede el propio usuario (su navegador) para obtener la
información. Por lo general, la convención utilizada es que todos los métodos y
rutas lleven el nombre del algoritmo.

Las primeras tareas para añadir un algoritmo nuevo serán incorporarlos al flujo
de las sesiones y actualizar la plantilla base (por la barra de navegación) y el
inicio. Para incorporarlos al flujo, esto se hace incorporándolos a la selección
(\texttt{/seleccionar/<algoritmo>}).

\textbf{Formularios}: A la hora de crear un nuevo algoritmo, y como se ha
comentado, el usuario tiene un paso de configuración del mismo. Esto se realiza
mediante un formulario. Para crear uno (WTForm), se debe crear su objeto
correspondiente en <<forms.py>> con los campos necesarios. Hasta el momento, los
algoritmos que hay implementados tienen una parte en común que está definida en
la clase <<\texttt{FormConfiguracionBase}>> y en prinicpio, si se añade uno
nuevo, deberá extender dicha clase.

\textbf{Plantillas (templates)}: Flask utiliza el motor de plantillas Jinja2,
que añaden instrucciones en HTML. Obviando que cada algoritmo tiene sus
particularidades, están organizadas mediante la extensión de plantillas. De
forma general, añadir un algoritmo podría solo intervenir la creación de una
plantilla de configuración (incluyendo la creación del formulario) y otra de
visualización. En ambos casos se tiene una plantilla base de la que se debe
extender. También se deben nombrar como resto de algoritmos (están nombrados de
forma intuitiva).

De forma general, las plantillas se encuentran repartidas en varios
subdirectorios, cada uno de ellos engloban una parte de la aplicación.

\begin{figure}[H]
    \dirtree{%
        .1 \textbf{templates}: \begin{minipage}[t]{10cm}
            plantillas HTML (Jinja2) que renderiza la aplicación Web
            (Flask){.}\\
        \end{minipage}.
        .2 \textbf{configuracion}: \begin{minipage}[t]{10cm}
            plantillas concretas de la ventana de configuración de la ejecución de los algoritmos{.}\\
        \end{minipage}.
        .2 \textbf{usuarios}: \begin{minipage}[t]{10cm}
            plantillas concretas de las distintas ventanas de los usuarios: login, registro, perfil, espacio personal y panel de administración{.}\\
        \end{minipage}.
        .2 \textbf{visualizacion}: \begin{minipage}[t]{10cm}
            plantillas concretas de las distintas ventanas de visualización de los algoritmos{.}\\
        \end{minipage}.
    }
\end{figure}

Debe evaluarse la adición de nuevas sub-carpetas si así fuera. Además, aquellas
plantillas que sean generales y no vinculadas a una parte concreta, se incluirán
directamente en \texttt{templates}.

\textbf{Ficheros estáticos (static)}: 

El contenido dinámico debe ser creado mediante Javascript, de forma <<vanilla>> 
(sin utilizar frameworks). 

Al igual que con las plantillas, es completamente necesario mantener la
organización actual de las carpetas, las funciones que se añadan deberán
incluirse en la carpeta de su contexto.

\begin{figure}[H]
    \dirtree{%
        .1 \textbf{js}: \begin{minipage}[t]{10cm}
            ficheros JavaScript{.}\\
        \end{minipage}.
        .2 \textbf{configuracion}: \begin{minipage}[t]{10cm}
            ficheros JavaScript encargados de la configuración de la ejecución de los algoritmos{.}\\
        \end{minipage}.
        .2 \textbf{usuarios}: \begin{minipage}[t]{10cm}
            ficheros JavaScript encargados de la generación de tablas y control del espacio personal de los usuarios y el panel de administración{.}\\
        \end{minipage}.
        .2 \textbf{visualizacion}: \begin{minipage}[t]{10cm}
            ficheros JavaScript encargados de la inicialización y generación de los gráficos en la visualización (gráfico principal y estadísticas){.}\\
        \end{minipage}.
    }
\end{figure}

En menor medida, los estilos deben ser retocados en estos ficheros
(\texttt{css/style.css}) aunque en principio la aplicación está estilada con
Bootstrap~5.

En estos ficheros estáticos también se tienen unas imágenes con los
pseudocódigos de los algoritmos. Estas imágenes deben verse tanto en la
configuración como la visualización.

Otra parte muy importante es si se quieren añadir nuevos clasificadores base con
sus parámetros, la especificación de los mismos está almacenada en el fichero
JSON <<parametros.json>>. 

Hasta el momento del desarrollo solo existen dos tipos de entradas, los
selectores y los numéricos.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Estructura para añadir clasificadores y sus parámetros]
\begin{minted}{json}
{
    "ClasificadorBase": {
        "parametro_numerico": {
        "label": "Nombre a mostrar",
        "type": "number",
        "step": 1,
        "min": 1,
        "max": "Infinity",
        "default": 5
        },
        "parametro_selector": {
        "label": "Nombre a mostrar",
        "type": "select",
        "options": ["lista", "de", "elementos"],
        "default": "elementos"
        }
    }
}
\end{minted}
\end{tcolorbox}

Con <<step>> se debe tener en cuenta la posibilidad de permitir números enteros
(al introducir 1) o números decimales (al incluir un flotante, por ejemplo,
0.01).

Según se ha codificado, la aparición de este nuevo clasificador será automática,
ya que una vez leído este fichero, JavaScript lo recorre creando tantas opciones
en los selectores como clasificadores haya y a su vez, todos los parámetros de
estos clasificadores.

Además de esto, hay tres zonas en la lógica de los \texttt{endpoints} que deben
ser modificadas si se añade un algoritmo. En <<\texttt{data\_routes.py}>>,
<<\texttt{configuration\_routes.py}>> y <<\texttt{visualization\_routes.py}>> se
tiene código específico para cada algoritmo. La <<activación>> de cada código se
realiza mediante un \textit{if} de tal forma que cuando coincide con el nombre
del algoritmo, se realizan ciertos pasos concretos para él. Se deberá ajustar la
lógica para el nuevo algoritmo.

En <<\texttt{data\_routes.py}>> se deberá crear la ruta de datos del algoritmo
(que se encarga de instanciar el algoritmo con los parámetros de la
configuración, y de ejecutarlo), en <<\texttt{configuration\_routes.py}>> es
donde se instancian los formularios de los algoritmos y en
<<\texttt{visualization\_routes.py}>> se obtienen los parámetros introducidos en
el formulario mediante una función creada para ello.

\textbf{Conjunto de datos (\textit{datasets})}: Los conjuntos de datos de los
usuarios (vinculados a sus sesiones) se almacenan localmente en la aplicación
con el <<Timestamp>> concatenado el nombre del fichero introducido.

Pero para agilizar el proceso del mantenimiento (principalmente del
almacenamiento del servidor), los ficheros subidos por usuarios anónimos se
guardan en una sub-carpeta distinta a la de los usuarios registrados.

\textbf{Internacionalización}: La aplicación está pensada para ser
internacionalizada en cualquier idioma, aunque solo se ha incluido inglés y
español. Una de las herramientas utilizadas es Babel, para incluir nuevo texto
en la aplicación se debe utilizar la función \texttt{gettext} o
\texttt{lazy\_gettext} (tanto en Jinja2 como Python si fuera necesario). El
proceso de extracción y compilación de las traducciones está explicado en la
siguiente sección.

Estas funciones envolventes no funcionan en JavaScript. Por si esto ocurre
durante el posterior desarrollo, se han considerado dos alternativas. 

Para el caso de las visualizaciones, en la plantilla
<<\texttt{base\_visualizacion}>> se ha incluido una función de traducción
embebida directamente en <<\texttt{</script>}>>. Al incluirse de esta forma,
Babel si puede capturar esas funciones. 

La otra posibilidad es mediante diccionarios y la declaración de una variable
que indique el idioma (\textit{locale}). Por ejemplo, en el espacio personal
(plantilla <<\texttt{miespacio}>>) y en el panel de administración (plantilla
<<\texttt{admin}>>), se ha definido una constante que consulta el idioma actual.
A partir de aquí, cuando existe un texto generado en JavaScript que necesita ser
traducido, se define un diccionario que contiene en los valores, las palabras
deseadas. Este diccionario realmente será un diccionario de diccionarios, el
primer nivel tendrá el idioma.

Ejemplo:

\begin{minted}{javascript}
    let diccionario = {
        "en": {"clave": "palabra en inglés"},
        "es": {"clave": "palabra en español"}
    };
\end{minted}

Ahora, cuando un texto ha de ser traducido, primero se accede al primer nivel y
luego a la palabra concreta.


\begin{minted}{javascript}
    // locale es la constante declarada en la propia plantilla
    let palabra_localizada = diccionario[locale]["clave"];
\end{minted}

\section{Compilación, instalación y ejecución del proyecto}

Para poner en funcionamiento la aplicación primero se debe preparar el entorno
de ejecución. Se recuerda la necesidad de tener instalado Python (y el
administrador de paquetes <<pip>>).

\paragraph{Código fuente de la aplicación} Para obtener el código fuente de la
aplicación, este debe ser descargado del repositorio Github utilizado\footnote{
Repositorio: \url{https://github.com/dma1004/TFG-SemiSupervisado}}.

Tanto en Windows como en Linux esto se puede realizar descargando el fichero
comprimido de todo el repositorio desde el navegador.

Pero si se quiere realizar mediante consola de comandos, y suponiendo que se ha
instalado Git:

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,fontupper=\footnotesize,title=Clonación de repositorio desde consola]
\begin{minted}{shell}
$ git clone https://github.com/dma1004/TFG-SemiSupervisado.git
\end{minted}
\end{tcolorbox}
La localización del proyecto queda a discreción del programador.
\paragraph{Entorno virtual Python} El entorno virtual no es estrictamente
necesario aunque es \textbf{altamente} recomendable, pues en los próximos pasos
se instalarán múltiples librerías que sin entorno virtual quedarían instaladas
globalmente. El proceso descrito a continuación puede ser sustituido en caso de
que solo se esté trabajando con Pycharm. Este editor permite crear entornos
virtuales e incluso realizarlo automáticamente al detectar los distintos
requisitos del proyecto. Pero de forma general, suponiendo que se desea preparar
un entorno de <<pruebas>> o <<producción>> y que la aplicación esté en
funcionamiento, se realizan los siguientes pasos:
\begin{tcolorbox}[colback=cyan!5!white,colframe=orange!75!black,title=Creación del entorno virtual (dentro de la carpeta deseado)]
\begin{minted}{shell}
$ python -m venv ./venv
\end{minted}
\end{tcolorbox}


\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,fontupper=\footnotesize,fontlower=\footnotesize,title=Activación del entorno virtual]
\begin{minted}{matlab}
$ venv\activate.bat //Windows
\end{minted}
\tcblower
\begin{minted}{matlab}
$ source ruta/al/entorno/virtual/bin/activate //Linux
\end{minted}
\end{tcolorbox}

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,title=Para desactivar el entorno (una vez en él)]
\begin{minted}{shell}
$ deactivate
\end{minted}
\end{tcolorbox}
\paragraph{Instalación de paquetes} En este paso se van a instalar todas las
librerías necesarias, el proyecto trae un fichero <<requirements.txt>> en el que
vienen especificados estos paquetes y sus versiones. Además, los algoritmos
implementados también están configurados como un paquete que puede ser
instalado.
\begin{tcolorbox}[colback=cyan!5!white,colframe=orange!75!black,title=Instalar librerías externas]
\begin{minted}{shell}
$ python -m pip install -r requierements.txt
\end{minted}
\end{tcolorbox}

\begin{tcolorbox}[colback=cyan!5!white,colframe=orange!75!black,title=Instalar paquete de algoritmos]
\begin{minted}{shell}
$ python -m pip install .
\end{minted}
\end{tcolorbox}

Por último, hay tres directorios que deben crearse para almacenar recursos de
los usuarios durante la ejecución.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,fontupper=\footnotesize,fontlower=\footnotesize,title=Creación de directorios (desde \texttt{/web/app})]
\begin{minted}{matlab}
//Windows
$ MD runs
$ MD datasets\anonimos
$ MD datasets\registrados
\end{minted}
\tcblower
\begin{minted}{shell}
//Linux
$ mkdir runs
$ mkdir datasets/anonimos
$ mkdir datasets/registrados
\end{minted}
\end{tcolorbox}


A partir de aquí ya se tiene configurado todo el entorno y los requisitos
necesarios para poder ejecutar la aplicación.

\paragraph{Ejecución} Referida a la ejecución de la aplicación Web (Flask), se
debe estar situado en el directorio \textbf{/web} del proyecto.
\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,fontupper=\footnotesize,fontlower=\footnotesize,title=Ejecución]
\begin{minted}{shell}
//Windows
$ set FLASK_APP=app.py
$ flask run
$ flask run --debug
\end{minted}
\tcblower
\begin{minted}{shell}
//Linux
$ flask run
$ flask run --debug
\end{minted}
\end{tcolorbox}

Existe una última cuestión que no es estrictamente necesaria para funcionar,
pero que añade la internacionalización a la aplicación automáticamente.

\paragraph{Internacionalización} En el caso de que se haya incluido más texto
traducido, este debe ser compilado con Babel para que la aplicación pueda
detectarlo.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,fontupper=\footnotesize,title=Proceso de internacionalización (desde \texttt{/web/app})]
\begin{minted}{shell}
Extraer los textos encapsulados por gettext
$ pybabel extract -F babel.cfg -o messages.pot .

Extraer los textos encapsulados por lazy_gettext
$ pybabel extract -F babel.cfg -k lazy_gettext -o messages.pot .

Actualizar los textos extraidos en el fichero de compilación
$ pybabel update -i messages.pot -d translations
\end{minted}
\end{tcolorbox}

Todos los pasos anteriores son \textbf{estrictamente} necesarios, si se realiza
una extracción sin incluir <<\texttt{lazy\_gettext}>> (por ejemplo) y a
continuación se actualizan las traducciones, se perderán aquellas que tenían
<<\texttt{lazy\_gettext}>>.

Una vez que se han extraido los textos, se han de indicar las traducciones.
Todos los textos envueltos por las funciones antes comentadas actúan como
identificadores. En \texttt{translations/es/LC\_MESSAGES/messages.po} se tienen
esos identificadores junto con la traducción (estará vacía si no se ha
introducido). En ese fichero se incluirán las traducciones.

El siguiente paso es la compilación de estas traducciones para que \texttt{Babel} pueda sustituir
los textos dinámicamente.

\begin{tcolorbox}[colback=cyan!5!white,colframe=cyan!75!black,fontupper=\footnotesize,title=Compilación de traducciones (desde \texttt{/web/app})]
\begin{minted}{shell}
Compilación de las traducciones
$ pybabel compile -d translations 
\end{minted}
\end{tcolorbox}